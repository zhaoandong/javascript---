## 理解对象
### 属性类型
#### 数据属性
+ [[Configurable]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，默认值是true。
+ [[Enumerable]: 表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，默认值是true。
+ [[Writeable]: 表示能否修改属性的值。直接在对象上定义的属性，默认值是true。
+ [[Value]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值得时候，把新值保存在这个位置。默认值是undefined

修改属性默认的特性，需要使用ES5的Object.defineProperty()，接收三个参数：属性所在的对象，属性的名字和一个描述符的对象
```
var person = {}
object.defineProperty(person,"name",{
    configurable:true,
    writable:false,
    numerable:true,
    value:'Nicholas'
    
})
```
+ 如果属性设置为只读，属性的值不可修改，尝试指定新值，非严格模式下，赋值操作将会被忽略；严格模式下，会抛出错误
+ configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，非严格模式下，什么都不会发生；严格模式下回抛出错误。一旦将属性定义为不可配置，就不可以将它变回可配置，此时调用object.defineProperty()修改除writable之外的特性，都会导致错误
+ 调用object.defineProperty()时，如果不指定，configurable、enumerable和writable默认为false
+ object.defineProperty()在IE8一下有兼容性问题

#### 访问器属性
> 访问器属性不包括数据值，包含一对getter和setter函数
+ [[Configurable]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，默认值是true。
+ [[Enumerable]: 表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，默认值是true。
+ [[Get]:读取属性时调用的函数，默认为undefined
+ [[Set]:写入属性时调用的函数，默认值为undefined
```
//访问器属性不能直接定义，必须使用Object.defineProperty()
var book = {
    _year:2004,
    edition:1
}
Object.defineProperty(book,'year',{
    get:function(){
        return this._year;
    },
    set: function(newValue){
        if(newValue > 2004){
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
})
book.year = 2005;
book.edition //2
```

### 定义多个属性
> ES5 定义了Object.defineProperties()方法，接收两个对象参数，第一个是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性--对应
```
var book = {}
Object.defineProperties(book,{
    _year:{
        value:2004
    },
    edition:{
        value:1
    },
    year{
        get:function(){
            return this._year;
        },
        set: function(newValue){
            if(newValue > 2004){
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
})
```

### 读取属性的特性
> ES5定义了 Object.getOwnPropertyDescriptor()方法，接收两个参数：属性所在的对象和要读取其描述符的属性名称。
+ 返回值是一个对象
+ 如果是访问器属性，这个对象的属性有confirgurable、enumerable、get和set;如果是数据属性，这个对象的属性有configurable、enumerable、writable和value
```
var book = {}
Object.defineProperties(book,{
    _year:{
        value:2004
    },
    edition:{
        value:1
    },
    year{
        get:function(){
            return this._year;
        },
        set: function(newValue){
            if(newValue > 2004){
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
})

var descriptor = Object.getOwnPropertyDescriptor(book,'_year');
descriptor.value  //2004
descriptor.configurable //false
typeof decriptor.get  //'undefined'

var descriptor = Object.getOwnPropertyDescriptor(book,'year');
descriptor.value  //undefined
descriptor.configurable //false
typeof decriptor.get  //function
```

## 创建对象
### 工厂模式
```
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}

var p1 = createPerson('Nick'，29,'doctor')
```

### 构造函数模式
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}

var person1 = new Person('Bill', 27, 'doctor');
var person2 = new Person('Nick', 32, 'techer');
```
person1 和 person2 保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person
```
person1.constructor == Person   //true
person2.constructor == Person   //true
```
对象的constructor 属性最初是用来标识对象类型的。但对于检测对象类型，instanceof 操作符更可靠
```
person1 instanceof Object  //true
person1 instanceof Person  //true
```
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定类型，这也是构造函数模式胜过工厂模式的地方。

#### 将构造函数当做函数
```
//当做构造函数使用
var person = new Person('Nick',29,'doctor');
person.sayName();  // 'Nick'


//作为普通函数调用
Person('Gerg',27,'doctor')  //添加到window
window.sayName();  //'Gerg'

// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o,'Krist', 25, 'Nurse');
o.sayName(); //'Krist'
```

### 原型模式
我们创先的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象